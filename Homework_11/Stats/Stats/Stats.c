/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.30 from the
 * contents of Stats.xs. Do not edit this file, edit Stats.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Stats.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

typedef struct {
    SV* code;
    HV* metrics;
    //AV* settings;
} METRIC;

typedef struct {
    AV* metrics;
} METRIC_ARRAY;

//METRIC_ARRAY * created_metrics = malloc( sizeof(METRIC_ARRAY) );
//created_metrics->metrics = newAV();

//METRIC * metrics[1];
bool flag = FALSE;

#line 33 "Stats.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 177 "Stats.c"

XS_EUPXS(XS_Stats_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Stats_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "code");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	code = ST(0)
;
#line 28 "Stats.xs"
        int count;
        printf ("1\n");

        METRIC * self = malloc( sizeof(METRIC) );
        self->code = code;
        self->metrics = newHV();
        //self->settings = newAV();
        //hv_store(self->metrics, "anc", 3, newSViv(7), 0);
        // Convert pointer to size_t
        size_t point_iv = PTR2IV(self);
        // Convert size_t to SV*
        SV* sv = newSViv(point_iv);
        // Create reference to SV*
        SV* svrv = newRV_inc(sv);
        // Create Object
        SV* obj = sv_bless(svrv, gv_stashpv(SvPV_nolen(ST(0)), 1));
        printf ("2\n");
/* GETTING THE STRUCTURE FIELDS
        METRIC* x;
        SV * sv_obj = SvRV(obj);
        size_t z = SvIV (sv_obj);
        x = INT2PTR(METRIC*, z);
 */
        XPUSHs(sv_2mortal(obj)); // x - это наша структура
/*------------------------*/
        //RETVAL = obj;
        //printf ("3\n");
        /*
        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        call_sv(callback, G_DISCARD|G_NOARGS);
        XPUSHs(sv_2mortal(newSViv(9)));
        PUTBACK;
        count = call_pv("Stats::x", G_SCALAR);
        SPAGAIN;
        XPUSHs(sv_2mortal(newSViv(count)));
        FREETMPS;
        LEAVE;
*/
#line 231 "Stats.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Stats_calculate_avg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Stats_calculate_avg)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "current_metric_values");
    {
	HV*	current_metric_values;

	STMT_START {
		SV* const xsub_tmp_sv = ST(0);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    current_metric_values = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Stats::calculate_avg",
				"current_metric_values");
		}
	} STMT_END
;
#line 72 "Stats.xs"
        char *sum = "sum";
        char *cnt = "cnt";
        int _sum;
        int _count;
        //printf ("1\n");
        SV* ptr_to_sum_value = *(hv_fetch(current_metric_values, sum, strlen(sum), 0));
        SV* ptr_to_cnt_value = *(hv_fetch(current_metric_values, cnt, strlen(cnt), 0));
        //printf ("2\n");

        //size_t size_sum_value =
        _sum = SvIV (ptr_to_sum_value);

        //printf ("%d\n", _sum);
        //size_t size_count_value =
        _count = SvIV (ptr_to_cnt_value);
        //printf ("%d\n", _count);
        //_sum = INT2PTR (int, size_sum_value);
        double _avg = _sum / _count;
        SV* avg = newSVnv(_avg);
        hv_store(current_metric_values, "avg", 3, avg, 0);
#line 281 "Stats.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Stats_stat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Stats_stat)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV*	self = ST(0)
;
	HV *	RETVAL;
#line 96 "Stats.xs"
        METRIC* calculated_metrics;
        SV * calculated_metrics_sv = SvRV(self);
        size_t size_calculated_metrics = SvIV (calculated_metrics_sv);
        calculated_metrics = INT2PTR(METRIC*, size_calculated_metrics);

        RETVAL = calculated_metrics->metrics;
        char * key;
        char * _settings = "_settings";

        I32 hash_keys_number = hv_iterinit(calculated_metrics->metrics);
        for (int i = 1; i < hash_keys_number; i++) {
            HE* x = hv_iternext(calculated_metrics->metrics);
            key = hv_iterkey(x, &hash_keys_number);
            printf("KEY: %s\n", key);

            SV* ptr_to_current_metric_values = *hv_fetch(calculated_metrics->metrics, key, strlen(key), 0);
            size_t size_current_metric_values = SvIV (ptr_to_current_metric_values);
            HV* current_metric_values = INT2PTR (HV*, size_current_metric_values);

            SV* sv_settings = *hv_fetch(current_metric_values, _settings, strlen(_settings), 0);
            size_t size_settings = SvIV(sv_settings);
            AV* settings = INT2PTR(AV*, size_settings);
            //
            if (-1 == av_len(settings)) {
                printf("NULL\n");
                //hv_undef(current_metric_values);
                hv_delete(calculated_metrics->metrics, key, strlen(key), 0);
                continue;
            }
            else {
                printf("NOT NULL\n");
            }
            //hv_fetch(x->metrics, name, strlen(name), 0);
        }
        RETVAL = calculated_metrics->metrics;

#line 334 "Stats.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Stats_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Stats_add)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, name, sv_value");
    {
	SV*	self = ST(0)
;
	char*	name = (char *)SvPV_nolen(ST(1))
;
	SV*	sv_value = ST(2)
;
	HV *	RETVAL;
#line 140 "Stats.xs"
        int count;
        char * settings_item;
        printf ("name: %s\n", name);
        METRIC* x;
        SV * ptr_to_self = SvRV(self);
        size_t z = SvIV (ptr_to_self);
        x = INT2PTR(METRIC*, z);
        //RETVAL = x->settings;

        //AV* settings = newAV();

        bool avg_flag = FALSE;
/*
        dSP;

        ENTER;
        SAVETMPS;
        PUSHMARK(SP);

        PUTBACK;
*/

        /*for (int j = 0; j < count; j++) {
            STRLEN len;
            SV *sv = av_shift(settings);
            char *s = SvPV(sv, len);
            printf("%s\n", s);
        }*/

        if (hv_exists(x->metrics, name, strlen(name))) {
            printf("UPDATE\n");

            SV* ptr_to_current_metric_values = *hv_fetch(x->metrics, name, strlen(name), 0);
            size_t size_current_metric_values = SvIV (ptr_to_current_metric_values);
            HV* current_metric_values = INT2PTR (HV*, size_current_metric_values);

            RETVAL = x->metrics;

            //HV* current_metric_values = *hv_fetch(x->metrics, name, strlen(name), 0);
            //SV* ptr_to_current_metric_values = *(hv_fetch(current_metric, sum, strlen(sum), 0));
            //size_t size_sum_value = SvIV (ptr_to_current_metric_values);
            //HV* current_metric = INT2PTR (HV*, size_sum_value);

            int value = SvIV (sv_value);
            //count = (int) av_len(x->settings) + 1;
            printf ("upd: %d\n", count);
            printf("value = %d\n", value);

            //for (int i = 0; i < 5; i++) {
                //STRLEN len;
                //SV *sv = newSVsv(*(av_fetch(x->settings, i, 1)));
                //printf ("upd: %d!!!\n", i);
                // = av_shift(settings);
                //char *s = SvPV(sv, len);
                //printf ("upd: %d\n", i);
                //printf("upd: %s\n", s);
                //if (!strcmp (s, "sum")) {


                /*---SUM---*/

                {
                    //printf("upd: %s!\n", s);
                    settings_item = "sum";
                    SV* ptr_to_sum_value = *(hv_fetch(current_metric_values, settings_item, strlen(settings_item), 0));
                    int current_sum_value = SvIV (ptr_to_sum_value);

                    current_sum_value += value;
                    printf ("cur = %d, val = %d\n", current_sum_value, value);

                    SV* current_sum = newSViv(current_sum_value);

                    hv_store(current_metric_values, settings_item, strlen(settings_item), current_sum, 0);
                }

                //if (!strcmp (s, "cnt"))
                /*---CNT---*/
                {
                    //printf("upd: %s!!\n", s);
                    settings_item = "cnt";
                    SV* ptr_to_cnt_value = *(hv_fetch(current_metric_values, settings_item, strlen(settings_item), 0));
                    int current_cnt_value = SvIV (ptr_to_cnt_value);

                    current_cnt_value++;
                    printf ("cur = %d\n", current_cnt_value);

                    SV* current_cnt = newSViv(current_cnt_value);

                    hv_store(current_metric_values, settings_item, strlen(settings_item), current_cnt, 0);
                }

                //if (!strcmp (s, "max"))
                {
                    //printf("upd: %s!!!\n", s);
                    settings_item = "max";
                    SV* ptr_to_max_value = *(hv_fetch(current_metric_values, settings_item, strlen(settings_item), 0));
                    int current_max_value = SvIV (ptr_to_max_value);

                    current_max_value = current_max_value > value ? current_max_value : value;

                    SV* current_max = newSViv(current_max_value);
                    hv_store(current_metric_values, settings_item, strlen(settings_item), current_max, 0);
                }

                //if (!strcmp (s, "min"))
                {
                    //prin tf("upd: %s!!!\n", s);
                    settings_item = "min";
                    SV* ptr_to_min_value = *(hv_fetch(current_metric_values, settings_item, strlen(settings_item), 0));
                    int current_min_value = SvIV (ptr_to_min_value);

                    //printf("__%s!!!\n", s);

                    current_min_value = value > current_min_value ? current_min_value : value;

                    printf ("cur = %d, val = %d\n", current_min_value, value);

                    SV* current_min = newSViv(current_min_value);
                    hv_store(current_metric_values, settings_item, strlen(settings_item), current_min, 0);
                }

                //if (!strcmp (s, "avg")) {
                //    printf("upd: %s!!\n", s);
                {
                    avg_flag = TRUE;
                }
            //}
            //if (avg_flag)
            /*---CALCULATE AVG---*/
            {
                char *sum = "sum";
                char *cnt = "cnt";
                int _sum;
                int _count;
                //printf ("1\n");
                SV* ptr_to_sum_value = *(hv_fetch(current_metric_values, sum, strlen(sum), 0));
                SV* ptr_to_cnt_value = *(hv_fetch(current_metric_values, cnt, strlen(cnt), 0));
                //printf ("2\n");

                //size_t size_sum_value =
                _sum = SvIV (ptr_to_sum_value);

                //printf ("%d\n", _sum);
                //size_t size_count_value =
                _count = SvIV (ptr_to_cnt_value);
                //printf ("%d\n", _count);
                //_sum = INT2PTR (int, size_sum_value);
                double _avg = _sum / _count;
                SV* avg = newSVnv(_avg);
                hv_store(current_metric_values, "avg", 3, avg, 0);
            }
            printf ("OK\n");
            //hv_store(x->metrics, name, strlen(name), newRV_inc((SV*) current_metric_values), 0);
            //x->metrics = current_metric_values;
            //RETVAL = x->metrics;
        }

        else {
            printf("INITIALIZE...\n");
            HV* metric_values = newHV();
            SV* unit = newSViv(1);
/*
            dSP;
            ENTER;
            SAVETMPS;
            PUSHMARK(SP);
            PUTBACK;
*/
            count = call_sv(x->code, G_ARRAY);
            SPAGAIN;
            //PUTBACK;
            //FREETMPS;
            //LEAVE;

            AV* _settings = newAV();

            for (int j = 0; j < count; j++) {
                //SV *sv_stack = POPs;
                //av_push(tmp_settings, sv_stack);
                av_push(_settings, newSVsv(POPs));
            }

            SV* settings_ref = newRV_inc((SV*) _settings);
            hv_store(metric_values, "_settings", 9, settings_ref, 0);
            //x->settings = tmp_settings;

            printf ("We have %d items in metric settings\n", count);
            //for (int i = 0; i < count; i++) {

                //STRLEN len;
                //printf ("i = %d\n", i);
                //SV *sv = newSVsv(*(av_fetch(x->settings, i, 1)));
                //SV *sv = *(av_fetch(x->settings, i, 1));
                //printf ("i = %d\n", i);
                //char *s = SvPV(sv, len);
                //printf ("%d\n", i);
                //printf("item = %s\n", s);
                //if (!strcmp (s, "sum")) {
                //printf("init: %s!\n", s);
                {
                    settings_item = "sum";
                    SV * sum_value = newSVsv(sv_value);
                    hv_store(metric_values, settings_item, strlen(settings_item), sum_value, 0);
                }
                //}
                //if (!strcmp (s, "cnt")) {
                //printf("init: %s!!\n", s);
                {
                    settings_item = "cnt";
                    hv_store(metric_values, settings_item, strlen(settings_item), unit, 0);
                }
                //}
                //if (!strcmp (s, "min"))
                {
                    //printf("init: %s!!!\n", s);
                    settings_item = "min";
                    SV * min_value = newSVsv(sv_value);
                    hv_store(metric_values, settings_item, strlen(settings_item), min_value, 0);
                }
                //if (!strcmp (s, "max"))
                {
                    //printf("init: %s!!!\n", s);
                    settings_item = "max";
                    SV * max_value = newSVsv(sv_value);
                    hv_store(metric_values, settings_item, strlen(settings_item), max_value, 0);
                }
                //if (!strcmp (s, "avg"))
                {
                    settings_item = "avg";
                    //printf("init: %s!!\n", s);
                    avg_flag = TRUE;
                }
            //}
            //if (avg_flag)
            {
                char *sum = "sum";
                char *cnt = "cnt";
                int _sum;
                int _count;
                //printf ("1\n");
                SV* ptr_to_sum_value = *(hv_fetch(metric_values, sum, strlen(sum), 0));
                SV* ptr_to_cnt_value = *(hv_fetch(metric_values, cnt, strlen(cnt), 0));
                //printf ("2\n");

                //size_t size_sum_value =
                _sum = SvIV (ptr_to_sum_value);

                //printf ("%d\n", _sum);
                //size_t size_count_value =
                _count = SvIV (ptr_to_cnt_value);
                //printf ("%d\n", _count);
                //_sum = INT2PTR (int, size_sum_value);
                double _avg = _sum / _count;
                SV* avg = newSVnv(_avg);
                hv_store(metric_values, "avg", 3, avg, 0);
            }
            //SV* q = newRV_inc((SV*) metric_values);
            hv_store(x->metrics, name, strlen(name), newRV_inc((SV*) metric_values), 0);
            //x->metrics = metric_values;
            RETVAL = x->metrics;
        }

        /*SV* name_len_sv;
        int name_len;
        name_len_sv = newSVpv(name, 0);
        name_len = (int) name_len_sv;
        printf ("name: %s\n", name);
        if (hv_exists(metrics, name, strlen(name))) {
            printf ("OK\n");
        }
        else {
            SV* sv_value = newRV_inc((SV*) value);
            if (!(store_res = hv_store(local_metrics, name, strlen(name), sv_value, 0))) {
                printf ("NOT STORED!\n");
            }
            else {
                metrics = local_metrics;
            }
        }
        RETVAL = metrics;
        printf ("1\n"); */
#line 642 "Stats.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Stats); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Stats)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("Stats::new", XS_Stats_new);
        newXS_deffile("Stats::calculate_avg", XS_Stats_calculate_avg);
        newXS_deffile("Stats::stat", XS_Stats_stat);
        newXS_deffile("Stats::add", XS_Stats_add);
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

