/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.30 from the
 * contents of Stats.xs. Do not edit this file, edit Stats.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Stats.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

typedef struct {
    SV* code;
    HV* metrics;
} METRIC;

/* TO GET THE STRUCTURE FIELDS:
        METRIC* x;
        SV * sv_obj = SvRV(obj);
        size_t z = SvIV (sv_obj);
        x = INT2PTR(METRIC*, z);
*/

#line 29 "Stats.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 173 "Stats.c"

XS_EUPXS(XS_Stats_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Stats_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "code");
    {
	SV*	code = ST(0)
;
	SV *	RETVAL;
#line 24 "Stats.xs"
        METRIC * self = malloc( sizeof(METRIC) );
        self->code = code;
        self->metrics = newHV();
        // Convert pointer to size_t
        size_t point_iv = PTR2IV(self);
        // Convert size_t to SV*
        SV* sv = newSViv(point_iv);
        // Create reference to SV*
        SV* svrv = newRV_inc(sv);
        // Create Object
        SV* obj_self = sv_bless(svrv, gv_stashpv(SvPV_nolen(ST(0)), 1));
        RETVAL = obj_self;
#line 198 "Stats.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Stats_stat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Stats_stat)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV*	self = ST(0)
;
	HV *	RETVAL;
#line 42 "Stats.xs"
        METRIC* calculated_metrics;
        SV * calculated_metrics_sv = SvRV(self);
        size_t size_calculated_metrics = SvIV (calculated_metrics_sv);
        calculated_metrics = INT2PTR(METRIC*, size_calculated_metrics);

        char * key;
        char * _settings = "_settings";
        HV* hash_to_output = newHV();

        I32 hash_keys_number = hv_iterinit(calculated_metrics->metrics);
        for (int i = 1; i < hash_keys_number; i++) {
            HE* self_metrics_hash_entry = hv_iternext(calculated_metrics->metrics);
            key = hv_iterkey(self_metrics_hash_entry, &hash_keys_number);

            SV* ptr_to_current_metric_values = *hv_fetch(calculated_metrics->metrics, key, strlen(key), 0);
            size_t size_current_metric_values = SvIV (ptr_to_current_metric_values);
            HV* current_metric_values = INT2PTR (HV*, size_current_metric_values);

            SV* sv_settings = *hv_fetch(current_metric_values, _settings, strlen(_settings), 0);
            size_t size_settings = SvIV(sv_settings);
            AV* settings = INT2PTR(AV*, size_settings);
            int len_settings = av_len(settings) + 1;

            if (0 == len_settings) {
                hv_delete(calculated_metrics->metrics, key, strlen(key), 0);
                continue;
            }
            else {
                HV* output_metric_values = newHV();
                STRLEN len;
                for (int j = 0; j < len_settings; j++) {
                    SV* sv_output_item = *av_fetch(settings, j, 0);
                    char *output_item = SvPV(sv_output_item, len);

                    SV * output_item_value = *hv_fetch(current_metric_values, output_item, strlen(output_item), 0);
                    hv_store(output_metric_values, output_item, strlen(output_item), output_item_value, 0);
                }
                hv_store(hash_to_output, key, strlen(key), newRV_inc((SV*) output_metric_values), 0);
            }
        }
        hv_undef(calculated_metrics->metrics);
        calculated_metrics->code = (SV*) NULL;
        RETVAL = hash_to_output;
#line 260 "Stats.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Stats_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Stats_add)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "_self, name, sv_value");
    {
	SV*	_self = ST(0)
;
	char*	name = (char *)SvPV_nolen(ST(1))
;
	SV*	sv_value = ST(2)
;
	HV *	RETVAL;
#line 93 "Stats.xs"
        int count;
        char * settings_item;
        METRIC* self;
        SV * ptr_to_self = SvRV(_self);
        size_t self_size = SvIV (ptr_to_self);
        self = INT2PTR(METRIC*, self_size);

        if (hv_exists(self->metrics, name, strlen(name))) {

            SV* ptr_to_current_metric_values = *hv_fetch(self->metrics, name, strlen(name), 0);
            size_t size_current_metric_values = SvIV (ptr_to_current_metric_values);
            HV* current_metric_values = INT2PTR (HV*, size_current_metric_values);

            RETVAL = self->metrics;

            int value = SvIV (sv_value);

            /*---SUM---*/

            {
                settings_item = "sum";
                SV* ptr_to_sum_value = *(hv_fetch(current_metric_values, settings_item, strlen(settings_item), 0));
                int current_sum_value = SvIV (ptr_to_sum_value);

                current_sum_value += value;

                SV* current_sum = newSViv(current_sum_value);

                hv_store(current_metric_values, settings_item, strlen(settings_item), current_sum, 0);
            }
                /*---CNT---*/
            {
                settings_item = "cnt";
                SV* ptr_to_cnt_value = *(hv_fetch(current_metric_values, settings_item, strlen(settings_item), 0));
                int current_cnt_value = SvIV (ptr_to_cnt_value);

                current_cnt_value++;

                SV* current_cnt = newSViv(current_cnt_value);

                hv_store(current_metric_values, settings_item, strlen(settings_item), current_cnt, 0);
            }

            {
                settings_item = "max";
                SV* ptr_to_max_value = *(hv_fetch(current_metric_values, settings_item, strlen(settings_item), 0));
                int current_max_value = SvIV (ptr_to_max_value);

                current_max_value = current_max_value > value ? current_max_value : value;

                SV* current_max = newSViv(current_max_value);
                hv_store(current_metric_values, settings_item, strlen(settings_item), current_max, 0);
            }

            {
                settings_item = "min";
                SV* ptr_to_min_value = *(hv_fetch(current_metric_values, settings_item, strlen(settings_item), 0));
                int current_min_value = SvIV (ptr_to_min_value);

                current_min_value = value > current_min_value ? current_min_value : value;

                SV* current_min = newSViv(current_min_value);
                hv_store(current_metric_values, settings_item, strlen(settings_item), current_min, 0);
            }

            /*---CALCULATE AVG---*/
            {
                char *sum = "sum";
                char *cnt = "cnt";
                int _sum;
                int _count;

                SV* ptr_to_sum_value = *(hv_fetch(current_metric_values, sum, strlen(sum), 0));
                SV* ptr_to_cnt_value = *(hv_fetch(current_metric_values, cnt, strlen(cnt), 0));

                _sum = SvIV (ptr_to_sum_value);
                _count = SvIV (ptr_to_cnt_value);

                double _avg = _sum / _count;
                SV* avg = newSVnv(_avg);
                hv_store(current_metric_values, "avg", 3, avg, 0);
            }
        }

        else {
            HV* metric_values = newHV();
            SV* unit = newSViv(1);
            count = call_sv(self->code, G_ARRAY);
            SPAGAIN;

            AV* _settings = newAV();

            for (int j = 0; j < count; j++) {
                av_push(_settings, newSVsv(POPs));
            }

            SV* settings_ref = newRV_inc((SV*) _settings);
            hv_store(metric_values, "_settings", 9, settings_ref, 0);

            {
                settings_item = "sum";
                SV * sum_value = newSVsv(sv_value);
                hv_store(metric_values, settings_item, strlen(settings_item), sum_value, 0);
            }

            {
                settings_item = "cnt";
                hv_store(metric_values, settings_item, strlen(settings_item), unit, 0);
            }

            {
                settings_item = "min";
                SV * min_value = newSVsv(sv_value);
                hv_store(metric_values, settings_item, strlen(settings_item), min_value, 0);
            }

            {
                settings_item = "max";
                SV * max_value = newSVsv(sv_value);
                hv_store(metric_values, settings_item, strlen(settings_item), max_value, 0);
            }

            {
                char *sum = "sum";
                char *cnt = "cnt";
                int _sum;
                int _count;

                SV* ptr_to_sum_value = *(hv_fetch(metric_values, sum, strlen(sum), 0));
                SV* ptr_to_cnt_value = *(hv_fetch(metric_values, cnt, strlen(cnt), 0));

                _sum = SvIV (ptr_to_sum_value);
                _count = SvIV (ptr_to_cnt_value);

                double _avg = _sum / _count;
                SV* avg = newSVnv(_avg);
                hv_store(metric_values, "avg", 3, avg, 0);
            }

            hv_store(self->metrics, name, strlen(name), newRV_inc((SV*) metric_values), 0);
            RETVAL = self->metrics;
        }
#line 429 "Stats.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Stats); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Stats)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("Stats::new", XS_Stats_new);
        newXS_deffile("Stats::stat", XS_Stats_stat);
        newXS_deffile("Stats::add", XS_Stats_add);
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

